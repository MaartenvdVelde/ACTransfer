define task list-recall {
  initial-goals: (read-in-memory rehearse report-vocal )
  goals: (be-lazy)
  task-constants: ( letter list say)
  start-screen: screen1
  imaginal-autoclear: t
  rt: -2.0
  default-activation: 1.0
}

define goal read-in-memory {
  operator read-first-letter  {
  "Read the first letter and put it in WM. Store goal id in WM"
    WM1=nil
    V1=letter
    ==>
   V2->WM3
   list->WM1
   G0->WM2
   nil->V1
  }

  operator read-next-letter {
  "Read the next letter, store it in WM"
    WM1<>nil
    V1=letter
    ==>
    V2->WM3
    list->WM1
    WM0->WM2
    nil->V1
  }
}

define goal report-vocal {
  operator start-report {
  "Retrieve the first item and bump anything remaining in WM to DM"
    V1=report
    RT1=nil
    ==>
    G0->RT2
    report->WM1
  }

  operator report-item {
  "Say item and retrieve next"
    V1=report
    ==>
    RT3->AC2
    say->AC1
    RT0->RT2
  }

  operator done-report {
  "On retrieval error end report"
    V1=report
    RT1=error
==>
    stop->G1
  }
}



define goal be-lazy {
  operator rehearse-no-rehearse {
    V1=nil
    ==>
    wait->AC1
  }
}

define facts {
 (x x)
 (k k)
 (p p)
 (f f)
}

define screen screen1 {
(letter x)
}

define screen screen2 {
(letter k)
}

define screen screen3 {
(letter p)
}

define screen screen4 {
(letter f)
}

define screen report {
(report)
}

transition(screen1,screen2) = absolute-time(2.0)
transition(screen2,screen3) = absolute-time(4.0)
transition(screen3,screen4) = absolute-time(6.0)
transition(screen4,report) = absolute-time(8.0)


