// Count the total number of spoons on two placemats
//

define task count-spoons {
    initial-goals: (add-all)
    goals: (count-goal determine-attribute)
//    task-constants: (item spoon placemat)
    imaginal-autoclear: nil
    rt: -2.0
    lf: 0.3
    ans: 0.1
    default-activation: 1.0
    references: (container item-type count-subtask action target fact-type)
}

define facts {
    (zero number-fact 0)
    (one number-fact 1)
    (two number-fact 2)
    (three number-fact 3)
    (four number-fact 4)
    (five number-fact 5)
    (six number-fact 6)
    (cf0 count-fact zero one)
    (cf1 count-fact  one  two)
    (cf2 count-fact  two  three)
    (cf3  count-fact  three  four)
    (cf4  count-fact  four  five)
    (cf5  count-fact  five  six)
}

define goal add-all {
    operator init-add-all {
        WM1=nil
        V1=screen
        ==>
        V>>V3  // shift to the first container (placemat)
        overall-total -> WM1
        zero -> WM3 // that is the current total
        WM>>WM4 // this should create a new chunk that is placed in WM4, and shifts focus to that chunk
        total-count -> WM1
    }

    operator add-result-to-total-retrieve {
        WM1 = overall-total
        WM>>WM4
        WM>>WM2
        WM1 = number-fact  /// this checks whether there is a number in the result slot (not strictly necessary in this model)
        WM<<
    ==>
        addition-fact -> RT1
        WM2 -> RT2
        WM<<
        WM3 -> RT3
        nil -> WM4
    }

    operator add-result-to-total-move-on {
        WM1 = overall-total
        RT1 = addition-fact
        V3 <> nil // There are still more containers
    ==>
        RT4 -> WM3
        V>>V3
        overall-total -> WM1
        zero -> WM3 // that is the current total
        WM>>WM4 // this should create a new chunk that is placed in WM4, and shifts focus to that chunk
    }

    operator add-result-to-total-move-on {
        WM1 = overall-total
        RT1 = addition-fact
        V3 = nil // No more containers
    ==>
        RT4 -> WM2 // This is the slot where the final total should end up
    }

    operator report-result {
        WM2 <> nil
        ==>
        action -> AC1
        WM2 -> AC2
        nil->G1
    }
}

define goal countgoal {
    operator init-countgoal {
        WM1 = total-count
        WM3 = nil
        V1 = container
        ==>
        zero -> WM3
        V>>V4 // shift to first item
        WM>>WM4 // Determine whether this is something that we need to count
        member -> WM1
    }

    operator move-one-if-not-countable-and-not-last {
        WM1 = total-count
        WM>>WM4
        WM2 = no
        WM<<
        V3 <> nil
        ==>
        V>>V3 // shift to next item
        nil -> WM4
        WM>>WM4
        member -> WM1
    }

    operator move-one-if-not-countable-and-last {
        WM1 = total-count
        WM>>WM4
        WM2 = no
        WM<<
        V3 = nil
        ==>
        WM3 -> WM2
        WM<<  // Shift up back to whoever wanted to count
        V<<  // Shift up back to container
    }

    operator retrieve-count-fact-for-countable-item {
        WM1 = total-count
        WM>>WM4
        WM2 = yes
        WM<<
    ==>
        count-fact -> RT1
        WM3 -> RT2
        nil -> WM4
    }

    operator add-count-and-not-last {
        RT1 = count-fact
        V3 <> nil
    ==>
        RT3 -> WM3
        WM>>WM4
        member -> WM1
    }

    operator add-count-last {
        RT1 = count-fact
        V3 = nil
    ==>
        RT3 -> WM2
        WM<<
        V<<
    }
}

define goal determine-attribute {

    operator answer-yes {
        WM1 = member
        V1 = item-type
        V2 = target
    ==>
        yes -> WM2
        WM<<
    }

    operator answer-yes {
        WM1 = member
        V1 = item-type
        V2 <> target
        ==>
        no -> WM2
        WM<<
    }

}


define script {
    screen(["placemat","one",
                ["item","fork"],
                ["item","fork"],
                ["item","plate"],
                ["item","knife"],
                ["item","spoon"]],
            ["placemat","two",
                ["item","fork"],
                ["item","plate"],
                ["item","knife"],
                ["item","spoon"],
                ["item","spoon"]])
    run-until-action("say")
    set-goal("add-all", ["container", "placemat"], ["item-type", "item"], ["count-subtask", "countgoal"],["action", "say"])
    set-goal("countgoal", ["start-number","zero"],["item-type", "item"], ["target","spoon"],["fact-type","count-fact"])

    issue-reward()
    trial-end()
}
