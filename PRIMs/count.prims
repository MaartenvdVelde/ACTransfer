// First example model: counting
// Adapted from the ACT-R tutorial by Niels Taatgen

define task count {
  initial-goals: (count) // In this example the task and the goal are the same
  start-screen: start
  imaginal-autoclear: nil
  ol: t
  rt: -2.0
  lf: 0.2
  default-operator-self-assoc: 0.0
}

define goal count {
  operator start-count(activation= 1.0) {
  "Start counting"
   V1 <> nil  // There has to be a visual input with the starting number
   WM1 = nil  // Imaginal should be empty
  ==>
   V1 -> WM1 // Copy the start number to working memory
   countfact -> RT1 // Start retrieving the next number
   V1 -> RT2
   say -> AC1 // Say the current number
   V1 -> AC2
   }

  operator iterate(activation=1.0) {
    "Iterate as long as count isn't done"
    RT2 = WM1
    V2 <> WM1
   ==>
    RT3 -> WM1
    countfact -> RT1
    RT3 -> RT2
    say -> AC1
    RT3 ->AC2
  }

  operator final(activation=1.0) {
    "Stop when reaching final number"
    V2 = WM1
   ==>
    say -> AC1
    stop -> AC2
    stop -> G1
  }
}

define facts {
(one 1) // Define the numbers themselves. Not really necessary for the model, but they show up in the DM graph.
(two 2)
(three 3)
(four 4)
(five 5)
(six 6)
(cf1 countfact  one  two :activation 1.0) // Countfacts. They receive a fixed activation for now
(cf2 countfact  two  three :activation 1.0)
(cf3  countfact  three  four :activation 1.0)
(cf4  countfact  four  five :activation 1.0)
(cf5  countfact  five  six :activation 1.0)
}

define screen start {
(?0 ?1)
}

define goal-action {
(say stop)
}

define inputs {
(two four)
(one three)
(three five)
}

