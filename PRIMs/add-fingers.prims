// This model performs addition by using its fingers to maintain one of the counters
// The "say" action also sticks up an additional finger
// This model will also work with imaginal-autoclear set to t

define task add-fingers {
initial-goals: (add-fingers)
start-screen: add
imaginal-autoclear: t
}


define goal add-fingers {

operator init-addition(activation=1.0) {
V1<>nil
WM1=nil
==>
V1->WM1
countfact->RT1
V1->RT2
say->AC1
V1->AC2
}

operator add-to-sum(activation=1.0) {
RT2=WM1
V2<>V3
==>
RT3->WM1
countfact->RT1
RT3->RT2
say->AC1
RT3->AC2
}


operator finished-sum(activation=1.0) {
V2=V3
==>
answer->AC1
RT3->AC2
stop->G1
}
}

define facts {
(one 1) 
(two 2)
(three 3)
(four 4)
(five 5)
(six 6)
(seven 7)
(eight 8)
(nine 9)
(cf0 countfact  zero  one :activation 3.0)
(cf1 countfact  one  two :activation 3.0)
(cf2 countfact  two  three :activation 3.0)
(cf3  countfact  three  four :activation 3.0)
(cf4  countfact  four  five :activation 3.0)
(cf5  countfact  five  six :activation 3.0)
(cf6  countfact  six  seven :activation 3.0)
(cf7  countfact  seven  eight :activation 3.0)
(cf8  countfact  eight  nine :activation 3.0)

}

define inputs {
(two three five)
(one two three)
(four two six)
}

define screen add {
(?0 ?1)
}

define screen one-finger {
(?0 ?1 one)
}


define screen two-finger {
(?0 ?1 two)
}


define screen three-finger {
(?0 ?1 three)
}

define screen four-finger {
(?0 ?1 four)
}

transition(add,one-finger) = action(say)
transition(one-finger,two-finger) = action(say)
transition(two-finger,three-finger) = action(say)
transition(three-finger,four-finger) = action(say)

define goal-action {
(answer ?2)
}

